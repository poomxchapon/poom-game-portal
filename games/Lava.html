<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Floor is Lava: LED Arcade</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Kanit:wght@300;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --tile-size: clamp(30px, 8vw, 60px);
            --gap-size: 4px;
            --color-floor: #1a1a1a;
            --color-safe: #00ff41;
            --color-warn: #ffae00;
            --color-lava: #ff003c;
            --p1-color: #00ccff;
            --p2-color: #d500f9;
            --bot-color: #ffffff;
        }

        body {
            font-family: 'Kanit', sans-serif;
            background-color: #050505;
            color: white;
            overflow: hidden;
            touch-action: none;
        }

        .font-arcade {
            font-family: 'Orbitron', sans-serif;
        }

        /* The Grid */
        #game-grid {
            display: grid;
            grid-template-columns: repeat(10, var(--tile-size));
            grid-template-rows: repeat(6, var(--tile-size));
            gap: var(--gap-size);
            padding: 10px;
            background: #111;
            border: 2px solid #333;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            position: relative;
        }

        /* Tile Styling */
        .tile {
            width: 100%;
            height: 100%;
            background-color: var(--color-floor);
            border-radius: 4px;
            transition: background-color 0.2s, box-shadow 0.2s;
            position: relative;
        }

        .tile.safe {
            background-color: var(--color-floor);
            box-shadow: inset 0 0 10px rgba(255,255,255,0.05);
        }

        .tile.safe-active {
            background-color: var(--color-safe);
            box-shadow: 0 0 20px var(--color-safe);
        }

        .tile.warning {
            animation: flashWarning 0.4s infinite alternate;
        }

        .tile.lava {
            background-color: var(--color-lava);
            box-shadow: 0 0 25px var(--color-lava);
            animation: lavaPulse 1.5s infinite;
        }

        /* Entities */
        .entity {
            position: absolute;
            width: calc(var(--tile-size) * 0.7);
            height: calc(var(--tile-size) * 0.7);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.15s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 10;
            border: 2px solid white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: black;
        }

        .p1 {
            background: var(--p1-color);
            box-shadow: 0 0 15px var(--p1-color);
            z-index: 20;
        }
        
        .p2 {
            background: var(--p2-color);
            box-shadow: 0 0 15px var(--p2-color);
            z-index: 20;
        }

        .bot {
            background: var(--bot-color);
            opacity: 0.6;
            box-shadow: 0 0 5px white;
            border: 1px solid #aaa;
            z-index: 5;
        }
        
        /* Team Colors Override */
        .team-blue { background: #0088ff !important; box-shadow: 0 0 10px #0088ff !important; }
        .team-red { background: #ff4444 !important; box-shadow: 0 0 10px #ff4444 !important; }

        .entity.dead {
            transform: translate(-50%, -50%) scale(0);
            opacity: 0;
        }
        
        .player.hit {
            animation: shake 0.5s;
            opacity: 0.5;
        }
        
        .blocked {
            animation: nudge 0.2s;
        }

        /* Animations */
        @keyframes flashWarning {
            0% { background-color: var(--color-floor); box-shadow: none; }
            100% { background-color: var(--color-warn); box-shadow: 0 0 15px var(--color-warn); }
        }

        @keyframes lavaPulse {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
            100% { filter: brightness(1); }
        }

        @keyframes shake {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-55%, -50%) rotate(-5deg); }
            75% { transform: translate(-45%, -50%) rotate(5deg); }
            100% { transform: translate(-50%, -50%) rotate(0deg); }
        }
        
        @keyframes nudge {
            0% { transform: translate(-50%, -50%); }
            50% { transform: translate(-50%, -50%) scale(0.9); }
            100% { transform: translate(-50%, -50%); }
        }

        /* UI Overlays */
        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .btn-start {
            background: linear-gradient(45deg, #00ff41, #00cc33);
            color: black;
            padding: 12px 30px;
            font-size: 1.2rem;
            font-weight: 900;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase;
            margin-top: 20px;
        }
        
        .btn-start:hover { transform: scale(1.05); box-shadow: 0 0 30px rgba(0, 255, 65, 0.8); }

        .form-group {
            margin-bottom: 15px;
            text-align: center;
            width: 100%;
            max-width: 300px;
        }
        
        .form-label {
            display: block;
            color: #aaa;
            margin-bottom: 5px;
            font-size: 0.9rem;
            font-family: 'Orbitron', sans-serif;
        }
        
        .btn-select {
            background: #222;
            border: 1px solid #444;
            color: white;
            padding: 8px 15px;
            margin: 0 2px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Kanit', sans-serif;
            transition: all 0.2s;
        }
        
        .btn-select.active {
            background: #00ccff;
            color: black;
            border-color: #00ccff;
            font-weight: bold;
        }

        .heart-icon {
            color: #ff003c;
            filter: drop-shadow(0 0 5px #ff003c);
        }
        
        /* Mobile Controls */
        #controls-hint {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            font-size: 0.8rem;
            color: #888;
        }
        .key-hint {
            display: inline-block;
            background: #333;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #555;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center relative select-none">

    <!-- Header UI -->
    <div class="absolute top-4 w-full px-6 flex justify-between items-center max-w-4xl z-50">
        <div class="flex flex-col">
            <h1 class="text-2xl font-arcade text-white tracking-wider text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-green-400 font-bold drop-shadow-lg">
                FLOOR IS LAVA
            </h1>
            <span class="text-xs text-gray-400 font-arcade tracking-widest">LED ARENA</span>
        </div>
        
        <div class="flex gap-4 sm:gap-6 items-center bg-gray-900/80 px-4 py-2 rounded-full border border-gray-700 shadow-xl backdrop-blur-sm">
            <!-- Timer Section -->
            <div class="flex items-center gap-2">
                <span class="text-blue-400 font-arcade text-sm hidden sm:inline">TIME</span>
                <span id="time-display" class="font-arcade text-xl text-white font-bold tracking-widest">01:30</span>
            </div>
            <div class="w-px h-6 bg-gray-600"></div>
            
            <!-- Rounds Section -->
            <div class="flex items-center gap-2">
                <span class="text-yellow-400 font-arcade text-sm hidden sm:inline">ROUNDS</span>
                <span id="score-display" class="font-arcade text-xl text-white font-bold">0</span>
            </div>
            <div class="w-px h-6 bg-gray-600"></div>
            
            <!-- Lives Section -->
            <div class="flex items-center gap-1" id="lives-container">
                <!-- Lives generated dynamically -->
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div id="status-text" class="mb-2 h-8 font-arcade text-lg font-bold text-center tracking-widest text-white drop-shadow-md">
        SETUP GAME
    </div>

    <!-- Game Container -->
    <div id="game-grid">
        <!-- Grid generated by JS -->
    </div>

    <div id="controls-hint" class="font-arcade">
        <span id="p1-hint" class="text-cyan-400">P1: <span class="key-hint">ARROWS</span></span>
        <span id="p2-hint" class="text-fuchsia-400 hidden">P2: <span class="key-hint">WASD</span></span>
    </div>

    <!-- Setup Menu Overlay -->
    <div id="setup-screen" class="overlay">
        <h2 class="text-3xl font-arcade text-white mb-2 font-bold tracking-widest text-center">GAME SETUP</h2>
        
        <!-- High Score Badge -->
        <div class="mb-6 px-4 py-1 bg-yellow-900/50 border border-yellow-600 rounded-full flex items-center gap-2">
            <span class="text-yellow-500 font-arcade text-sm">üèÜ BEST RECORD</span>
            <span id="menu-high-score" class="text-yellow-400 font-arcade text-xl font-bold">0</span>
        </div>
        
        <div class="form-group">
            <label class="form-label">GAME MODE</label>
            <div class="flex justify-center gap-2">
                <button class="btn-select active" onclick="ui.setMode('solo')">SOLO / FFA</button>
                <button class="btn-select" onclick="ui.setMode('team')">TEAM (Red vs Blue)</button>
            </div>
        </div>

        <div class="form-group">
            <label class="form-label">HUMAN PLAYERS</label>
            <div class="flex justify-center gap-2">
                <button class="btn-select active" onclick="ui.setHumans(1)">1 Player</button>
                <button class="btn-select" onclick="ui.setHumans(2)">2 Players</button>
            </div>
        </div>

        <div class="form-group">
            <label class="form-label">TOTAL ENTITIES (With Bots)</label>
            <div class="flex justify-center gap-1 flex-wrap">
                <button class="btn-select active" onclick="ui.setTotal(2)">2</button>
                <button class="btn-select" onclick="ui.setTotal(3)">3</button>
                <button class="btn-select" onclick="ui.setTotal(4)">4</button>
                <button class="btn-select" onclick="ui.setTotal(5)">5</button>
                <button class="btn-select" onclick="ui.setTotal(6)">6</button>
            </div>
            <p class="text-xs text-gray-500 mt-2" id="bot-count-text">Bots will fill empty slots</p>
        </div>

        <button class="btn-start font-arcade" onclick="game.start()">START GAME</button>
    </div>

    <!-- Game Over Overlay -->
    <div id="game-over-screen" class="overlay hidden">
        <h2 id="end-title" class="text-5xl font-arcade text-red-500 mb-2 font-bold drop-shadow-lg text-center">GAME OVER</h2>
        <div class="text-center mb-8 relative">
            <p class="text-gray-400 text-sm mb-1">ROUNDS SURVIVED</p>
            <p id="final-score" class="text-6xl text-white font-arcade font-bold">0</p>
            
            <!-- New Record Badge (Hidden by default) -->
            <div id="new-record-badge" class="hidden absolute -top-6 -right-12 rotate-12 bg-yellow-500 text-black font-arcade font-bold text-xs px-2 py-1 rounded shadow-lg animate-bounce">
                NEW RECORD!
            </div>
        </div>
        <button class="btn-start font-arcade" onclick="ui.showSetup()">MAIN MENU</button>
    </div>

    <script>
        // UI Manager
        class UIManager {
            constructor() {
                this.config = {
                    mode: 'solo',
                    humans: 1,
                    total: 2
                };
                // Load High Score
                this.highScore = parseInt(localStorage.getItem('lava_highscore')) || 0;
            }

            setMode(mode) {
                this.config.mode = mode;
                document.querySelectorAll('[onclick^="ui.setMode"]').forEach(b => b.classList.remove('active'));
                event.target.classList.add('active');
            }

            setHumans(count) {
                this.config.humans = count;
                document.querySelectorAll('[onclick^="ui.setHumans"]').forEach(b => b.classList.remove('active'));
                event.target.classList.add('active');
                
                if (this.config.total < count) {
                    this.setTotal(count);
                }
                this.updateBotText();
            }

            setTotal(count) {
                if (count < this.config.humans) return; 
                this.config.total = count;
                document.querySelectorAll('[onclick^="ui.setTotal"]').forEach(b => b.classList.remove('active'));
                Array.from(document.querySelectorAll('[onclick^="ui.setTotal"]')).find(b => b.textContent == count).classList.add('active');
                this.updateBotText();
            }
            
            updateBotText() {
                const botCount = this.config.total - this.config.humans;
                const text = botCount > 0 ? `+ ${botCount} Bot(s)` : 'No Bots';
                document.getElementById('bot-count-text').textContent = text;
            }
            
            updateHighScoreDisplay() {
                document.getElementById('menu-high-score').textContent = this.highScore;
            }

            checkHighScore(currentScore) {
                const badge = document.getElementById('new-record-badge');
                if (currentScore > this.highScore) {
                    this.highScore = currentScore;
                    localStorage.setItem('lava_highscore', this.highScore);
                    badge.classList.remove('hidden');
                    return true;
                } else {
                    badge.classList.add('hidden');
                    return false;
                }
            }

            showSetup() {
                this.updateHighScoreDisplay();
                document.getElementById('game-over-screen').classList.add('hidden');
                document.getElementById('setup-screen').classList.remove('hidden');
                game.state = 'menu';
            }
        }

        const ui = new UIManager();

        class FloorIsLava {
            constructor() {
                this.cols = 10;
                this.rows = 6;
                this.grid = [];
                this.players = [];
                this.bots = [];
                this.score = 0;
                this.state = 'menu'; 
                this.roundState = 'safe';
                this.gridElement = document.getElementById('game-grid');
                this.statusElement = document.getElementById('status-text');
                
                // Timer
                this.timeRemaining = 90; // Seconds
                this.timerInterval = null;

                this.initGrid();
                this.setupInputs();
            }

            initGrid() {
                this.gridElement.innerHTML = '';
                this.grid = [];
                
                for (let y = 0; y < this.rows; y++) {
                    const row = [];
                    for (let x = 0; x < this.cols; x++) {
                        const tile = document.createElement('div');
                        tile.classList.add('tile');
                        this.gridElement.appendChild(tile);
                        row.push({ element: tile, type: 'safe' });
                    }
                    this.grid.push(row);
                }
            }

            setupInputs() {
                window.addEventListener('keydown', (e) => {
                    if (this.state !== 'playing') return;
                    
                    // P1 Controls (Arrows)
                    const p1 = this.players.find(p => p.id === 1);
                    if (p1 && p1.alive) {
                        switch(e.code) {
                            case 'ArrowUp': this.move(p1, 0, -1); break;
                            case 'ArrowDown': this.move(p1, 0, 1); break;
                            case 'ArrowLeft': this.move(p1, -1, 0); break;
                            case 'ArrowRight': this.move(p1, 1, 0); break;
                        }
                    }

                    // P2 Controls (WASD)
                    const p2 = this.players.find(p => p.id === 2);
                    if (p2 && p2.alive) {
                        switch(e.code) {
                            case 'KeyW': this.move(p2, 0, -1); break;
                            case 'KeyS': this.move(p2, 0, 1); break;
                            case 'KeyA': this.move(p2, -1, 0); break;
                            case 'KeyD': this.move(p2, 1, 0); break;
                        }
                    }
                });
            }

            // Check if any entity occupies (x,y)
            isOccupied(x, y) {
                // Check Players
                if (this.players.some(p => p.alive && p.x === x && p.y === y)) return true;
                // Check Bots
                if (this.bots.some(b => b.alive && b.x === x && b.y === y)) return true;
                
                return false;
            }

            move(entity, dx, dy) {
                const newX = entity.x + dx;
                const newY = entity.y + dy;

                if (newX >= 0 && newX < this.cols && newY >= 0 && newY < this.rows) {
                    // Collision Check
                    if (!this.isOccupied(newX, newY)) {
                        entity.x = newX;
                        entity.y = newY;
                        this.updateEntityPosition(entity);
                    } else {
                        // Visual feedback for blocked
                        const el = document.getElementById(entity.elId);
                        if(el) {
                            el.classList.remove('blocked');
                            void el.offsetWidth; // trigger reflow
                            el.classList.add('blocked');
                        }
                    }
                }
            }

            updateEntityPosition(entity) {
                const el = document.getElementById(entity.elId);
                if (el) {
                    el.style.left = `calc(${entity.x * 100 / this.cols}% + ${100/this.cols/2}%)`;
                    el.style.top = `calc(${entity.y * 100 / this.rows}% + ${100/this.rows/2}%)`;
                }
            }

            spawnEntity(type, id, x, y, team = null) {
                const elId = `${type}-${id}`;
                const el = document.createElement('div');
                el.id = elId;
                el.classList.add('entity', type);
                el.textContent = type === 'p' ? `P${id}` : '';
                
                if (ui.config.mode === 'team' && team) {
                    el.classList.add(team === 'blue' ? 'team-blue' : 'team-red');
                } else if (type === 'p') {
                    el.classList.add(id === 1 ? 'p1' : 'p2');
                } else {
                    el.classList.add('bot');
                }

                this.gridElement.appendChild(el);
                
                const entity = { x, y, id, type, elId, alive: true, lives: 3, team };
                this.updateEntityPosition(entity);
                return entity;
            }

            start() {
                const config = ui.config;
                
                document.getElementById('setup-screen').classList.add('hidden');
                document.getElementById('game-over-screen').classList.add('hidden');
                document.querySelectorAll('.entity').forEach(e => e.remove());

                this.state = 'playing';
                this.score = 0;
                this.players = [];
                this.bots = [];
                
                // Reset & Start Timer
                this.timeRemaining = 90; // 1:30
                this.updateTimeDisplay();
                this.startTimer();
                
                document.getElementById('p2-hint').style.display = config.humans > 1 ? 'inline' : 'none';

                // Spawn Humans (Check collision not needed for fixed start points unless overlapping)
                this.players.push(this.spawnEntity('p', 1, 2, 2, config.mode === 'team' ? 'blue' : null));
                
                if (config.humans > 1) {
                    this.players.push(this.spawnEntity('p', 2, 7, 3, config.mode === 'team' ? 'red' : null));
                }

                // Spawn Bots
                const botCount = config.total - config.humans;
                for (let i = 0; i < botCount; i++) {
                    let bx, by;
                    let attempts = 0;
                    
                    // Find empty spot
                    do {
                        bx = Math.floor(Math.random() * this.cols);
                        by = Math.floor(Math.random() * this.rows);
                        attempts++;
                    } while (this.isOccupied(bx, by) && attempts < 50);

                    let team = null;
                    if (config.mode === 'team') {
                        if (config.humans === 1) {
                             team = (i % 2 === 0) ? 'red' : 'blue';
                        } else {
                             team = (i % 2 === 0) ? 'blue' : 'red';
                        }
                    }
                    
                    this.bots.push(this.spawnEntity('bot', i, bx, by, team));
                }

                this.updateUI();
                this.startRoundLoop();
            }

            startTimer() {
                if (this.timerInterval) clearInterval(this.timerInterval);
                
                this.timerInterval = setInterval(() => {
                    if (this.state !== 'playing') {
                        clearInterval(this.timerInterval);
                        return;
                    }
                    
                    this.timeRemaining--;
                    this.updateTimeDisplay();
                    
                    if (this.timeRemaining <= 0) {
                        this.gameVictory();
                    }
                }, 1000);
            }

            updateTimeDisplay() {
                const min = Math.floor(this.timeRemaining / 60);
                const sec = this.timeRemaining % 60;
                document.getElementById('time-display').textContent = 
                    `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
                
                // Visual warning
                if (this.timeRemaining <= 10) {
                     document.getElementById('time-display').classList.add('text-red-500');
                     document.getElementById('time-display').classList.remove('text-white');
                } else {
                     document.getElementById('time-display').classList.remove('text-red-500');
                     document.getElementById('time-display').classList.add('text-white');
                }
            }

            updateUI() {
                document.getElementById('score-display').textContent = this.score;
                
                const container = document.getElementById('lives-container');
                container.innerHTML = '';
                
                this.players.forEach(p => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center gap-1 mr-4';
                    div.innerHTML = `<span class="text-xs font-bold ${p.id===1?'text-cyan-400':'text-fuchsia-400'}">P${p.id}</span>`;
                    
                    for(let i=0; i<p.lives; i++) {
                         div.innerHTML += `<svg class="w-4 h-4 heart-icon fill-current" viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>`;
                    }
                    container.appendChild(div);
                });
            }

            async startRoundLoop() {
                while (this.state === 'playing') {
                    if (this.players.every(p => !p.alive)) {
                        this.gameOver();
                        break;
                    }

                    // 1. Safe Phase
                    this.roundState = 'safe';
                    this.setAllTiles('safe');
                    this.statusElement.textContent = "SAFE ZONE";
                    this.statusElement.style.color = "#00ff41";
                    
                    await this.wait(1500);
                    if (this.state !== 'playing') break;

                    // 2. Select Safe Spots
                    const safeCount = Math.max(2, 6 - Math.floor(this.score / 3)); 
                    const safeSpots = this.generateSafeSpots(safeCount);
                    
                    // 3. Warning
                    this.roundState = 'warning';
                    this.statusElement.textContent = "WARNING!";
                    this.statusElement.style.color = "#ffae00";
                    this.applyGridState(safeSpots, 'warning');
                    
                    const warningTime = Math.max(1500, 2500 - (this.score * 50));
                    this.moveBots(safeSpots, warningTime);
                    
                    await this.wait(warningTime);
                    if (this.state !== 'playing') break;

                    // 4. Lava Phase
                    this.roundState = 'lava';
                    this.statusElement.textContent = "LAVA!";
                    this.statusElement.style.color = "#ff003c";
                    this.applyGridState(safeSpots, 'lava');
                    
                    this.checkDamage();
                    this.checkBots();
                    
                    if (this.players.some(p => p.alive)) {
                        this.score++;
                        this.updateUI();
                    }

                    await this.wait(2000);
                }
            }

            checkDamage() {
                this.players.forEach(p => {
                    if (!p.alive) return;
                    const tile = this.grid[p.y][p.x];
                    if (tile.type === 'lava') {
                        p.lives--;
                        const el = document.getElementById(p.elId);
                        el.classList.add('hit');
                        setTimeout(() => el.classList.remove('hit'), 500);
                        
                        if (p.lives <= 0) {
                            p.alive = false;
                            el.classList.add('dead');
                        }
                    }
                });
                this.updateUI();
            }

            checkBots() {
                this.bots.forEach(b => {
                    if (!b.alive) return;
                    const tile = this.grid[b.y][b.x];
                    if (tile.type === 'lava') {
                        b.alive = false;
                        document.getElementById(b.elId).classList.add('dead');
                    }
                });

                if (this.bots.every(b => !b.alive) && Math.random() > 0.5) {
                    setTimeout(() => this.respawnBots(), 1000);
                }
            }
            
            respawnBots() {
                this.bots.forEach(b => {
                    b.alive = true;
                    // Respawn logic needs collision check too
                    let bx, by;
                    let attempts = 0;
                    do {
                        bx = Math.floor(Math.random() * this.cols);
                        by = Math.floor(Math.random() * this.rows);
                        attempts++;
                    } while (this.isOccupied(bx, by) && attempts < 50);

                    b.x = bx;
                    b.y = by;
                    const el = document.getElementById(b.elId);
                    el.classList.remove('dead');
                    this.updateEntityPosition(b);
                });
            }

            generateSafeSpots(count) {
                const spots = [];
                while(spots.length < count) {
                    const x = Math.floor(Math.random() * this.cols);
                    const y = Math.floor(Math.random() * this.rows);
                    if (!spots.some(s => s.x === x && s.y === y)) {
                        spots.push({x, y});
                    }
                }
                return spots;
            }

            applyGridState(safeSpots, phase) {
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        const tileObj = this.grid[y][x];
                        const isSafe = safeSpots.some(s => s.x === x && s.y === y);
                        tileObj.element.className = 'tile'; 
                        if (phase === 'warning') {
                            if (!isSafe) {
                                tileObj.element.classList.add('warning');
                                tileObj.type = 'danger';
                            } else {
                                tileObj.type = 'safe';
                            }
                        } else if (phase === 'lava') {
                            if (!isSafe) {
                                tileObj.element.classList.add('lava');
                                tileObj.type = 'lava';
                            } else {
                                tileObj.element.classList.add('safe-active');
                                tileObj.type = 'safe';
                            }
                        }
                    }
                }
            }

            moveBots(safeSpots, timeAvailable) {
                const steps = 5;
                const interval = timeAvailable / steps;
                let stepCount = 0;
                
                const botInterval = setInterval(() => {
                    if (this.state !== 'playing' || this.roundState !== 'warning') {
                        clearInterval(botInterval);
                        return;
                    }
                    this.bots.forEach(bot => {
                        if (!bot.alive) return;
                        let nearest = null;
                        let minDist = 999;
                        safeSpots.forEach(spot => {
                            const d = Math.abs(spot.x - bot.x) + Math.abs(spot.y - bot.y);
                            if (d < minDist) { minDist = d; nearest = spot; }
                        });
                        
                        if (nearest && minDist > 0) {
                            const dx = nearest.x - bot.x;
                            const dy = nearest.y - bot.y;
                            
                            let moveX = 0;
                            let moveY = 0;

                            // Prefer largest distance axis
                            if (Math.abs(dx) > Math.abs(dy)) {
                                moveX = dx > 0 ? 1 : -1;
                            } else {
                                moveY = dy > 0 ? 1 : -1;
                            }

                            // 1. Try Primary Move
                            if (!this.isOccupied(bot.x + moveX, bot.y + moveY)) {
                                bot.x += moveX;
                                bot.y += moveY;
                            } else {
                                // 2. Try Secondary Move (If blocked, try moving on other axis)
                                if (moveX !== 0 && dy !== 0) {
                                     // Was moving X, try Y
                                     moveY = dy > 0 ? 1 : -1;
                                     moveX = 0;
                                     if (!this.isOccupied(bot.x, bot.y + moveY)) bot.y += moveY;
                                } else if (moveY !== 0 && dx !== 0) {
                                     // Was moving Y, try X
                                     moveX = dx > 0 ? 1 : -1;
                                     moveY = 0;
                                     if (!this.isOccupied(bot.x + moveX, bot.y)) bot.x += moveX;
                                }
                            }
                            this.updateEntityPosition(bot);
                        }
                    });
                    stepCount++;
                    if (stepCount >= steps) clearInterval(botInterval);
                }, interval);
            }

            setAllTiles(type) {
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        this.grid[y][x].element.className = 'tile ' + type;
                        this.grid[y][x].type = type;
                    }
                }
            }
            
            wait(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
            
            gameOver() {
                clearInterval(this.timerInterval);
                this.state = 'gameover';
                document.getElementById('final-score').textContent = this.score;
                
                // Check High Score
                ui.checkHighScore(this.score);
                
                // Set Game Over Style
                const title = document.getElementById('end-title');
                title.textContent = "GAME OVER";
                title.classList.remove('text-green-500');
                title.classList.add('text-red-500');
                
                document.getElementById('game-over-screen').classList.remove('hidden');
            }

            gameVictory() {
                clearInterval(this.timerInterval);
                this.state = 'gameover'; // Stop loop
                document.getElementById('final-score').textContent = this.score;

                // Check High Score
                ui.checkHighScore(this.score);
                
                // Set Victory Style
                const title = document.getElementById('end-title');
                title.textContent = "SURVIVED!";
                title.classList.remove('text-red-500');
                title.classList.add('text-green-500');
                
                document.getElementById('game-over-screen').classList.remove('hidden');
            }
        }

        const game = new FloorIsLava();
        ui.showSetup();
    </script>
</body>
</html>

